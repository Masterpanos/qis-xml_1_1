<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2007 (http://www.altova.com) by Pascal Heus (Open Data Foundation) -->
<xs:schema xmlns="qis:program:1_1" xmlns:c="qis:circuit:1_1" xmlns:r="qis:reusable:1_1" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ns1="qis:reusable:1_1" xmlns:ns2="qis:circuit:1_1" targetNamespace="qis:program:1_1" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<xs:import namespace="qis:circuit:1_1" schemaLocation="qis.circuit.xsd"/>
	<xs:import namespace="qis:reusable:1_1" schemaLocation="qis.reusable.xsd"/>
	<xs:element name="ProgramLibrary" type="ProgramLibraryType"/>
	<xs:complexType name="ProgramLibraryType">
		<xs:sequence>
			<xs:element ref="r:Identification"/>
			<xs:element name="Name" type="xs:string" minOccurs="0"/>
			<xs:element name="Program" type="ProgramType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Program" type="ProgramType"/>
	<xs:complexType name="ProgramType">
		<xs:sequence>
			<xs:element ref="r:Identification" minOccurs="0"/>
			<xs:element name="Name" type="xs:string" minOccurs="0"/>
			<xs:element name="Description" type="xs:string" minOccurs="0"/>
			<xs:element ref="Memory">
				<xs:annotation>
					<xs:documentation>Program memory pool used be Registry (inspired by QCL)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="Register" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A global register that can be refered from Execute elements. If is hightly recommended for such register to contain an r:Indetiofication element (but it could also be referred to by idnex value). This is a bit equivalent of a global variable.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>On or more circuit followed by optional measurement (if not specified, assumes the whole memeory is measured and returned)</xs:documentation>
				</xs:annotation>
				<xs:element name="Execute">
					<xs:annotation>
						<xs:documentation>Circuit to execute</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:choice minOccurs="0">
								<xs:element ref="Register">
									<xs:annotation>
										<xs:documentation>A subset of qubits from the main program memory to use for this circuit. If not specified, assume that the whole memory is used. This is a bit equivalent ot a local variable.</xs:documentation>
									</xs:annotation>
								</xs:element>
								<xs:element name="RegisterRef" type="r:ReferenceType"/>
							</xs:choice>
							<xs:choice>
								<xs:annotation>
									<xs:documentation>Provides reference to the Circuit or an inline Circuit</xs:documentation>
								</xs:annotation>
								<xs:element name="CircuitRef" type="r:ReferenceType">
									<xs:annotation>
										<xs:documentation>Reference to a circuit in a library</xs:documentation>
									</xs:annotation>
								</xs:element>
								<xs:element ref="c:Circuit"/>
								<xs:element ref="Program">
									<xs:annotation>
										<xs:documentation>EXPERIMENTAL: calls a subprogram
Need to think how this might work memory wise. May need to wrap in a SubProgram element and add a register (like Exeecute).</xs:documentation>
									</xs:annotation>
								</xs:element>
								<xs:element name="ProgramRef" type="r:ReferenceType">
									<xs:annotation>
										<xs:documentation>Reference to a Program in a ProgramLibrary</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:choice>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="Measure">
					<xs:annotation>
						<xs:documentation>Can be used to cause a measurement of a specific set of qubit in the memory
This allows to ((1) run a ciruit, measure, and then run another circuit, (2) when this is the last element, to measure and return only a subset of the memory.
In case (1), this should cause  a "returned" value to be sent to the classicial world</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="Register"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Memory" type="MemoryType"/>
	<xs:complexType name="MemoryType">
		<xs:sequence>
			<xs:element ref="r:Identification" minOccurs="0"/>
			<xs:element name="Name" type="xs:string" minOccurs="0"/>
			<xs:element ref="Prepare" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Prepares the memory</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Qubit" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Can be use to actually store memory values. Note that this element extends the r:Qubit type by adding an index attribute.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="r:QubitType">
							<xs:attribute name="index" use="required"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="size" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>Number of qubits</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="Register" type="RegisterType"/>
	<xs:complexType name="RegisterType">
		<xs:annotation>
			<xs:documentation>A collection of references to Memory location. If not specific qubits are reference, the Register is assumed to use all available Memory qubits</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="r:Identification" minOccurs="0"/>
			<xs:element name="Name" type="xs:string" minOccurs="0"/>
			<xs:element name="MemoryReference" type="r:ReferenceType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>May be used in the future to reference global memory or memory in another program</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="QubitIndex" type="xs:positiveInteger">
					<xs:annotation>
						<xs:documentation>A single qubit location</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="QubitRange">
					<xs:annotation>
						<xs:documentation>A range of qubits</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="StartQubit" type="xs:positiveInteger"/>
							<xs:element name="EndQubit" type="xs:positiveInteger"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="RegisterReference">
					<xs:annotation>
						<xs:documentation>Includes another Register's qubits</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element ref="Prepare" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Prepares the register</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="size" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:element name="Prepare" type="PrepareType"/>
	<xs:complexType name="PrepareType">
		<xs:sequence>
			<xs:element name="QubitSet" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Set the value of qubit(s)</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:choice maxOccurs="unbounded">
							<xs:element name="QubitIndex" type="xs:positiveInteger">
								<xs:annotation>
									<xs:documentation>A single qubit location</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="QubitRange">
								<xs:annotation>
									<xs:documentation>A range of qubits</xs:documentation>
								</xs:annotation>
								<xs:complexType>
									<xs:sequence>
										<xs:element name="StartQubit" type="xs:positiveInteger"/>
										<xs:element name="EndQubit" type="xs:positiveInteger"/>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:choice>
						<xs:element name="Value" type="r:ComplexNumberType"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="reset" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Resets all qubits to zero</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
</xs:schema>
